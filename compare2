def equalize_adapthist(image, ntiles_x=None, ntiles_y=None, clip_limit=0.01,
                       nbins=256, kernel_size=None):
    """Contrast Limited Adaptive Histogram Equalization (CLAHE).
 
    An algorithm for local contrast enhancement, that uses histograms computed
    over different tile regions of the image. Local details can therefore be
    enhanced even in regions that are darker or lighter than most of the image.
 
    Parameters
    ----------
    image : array-like
        Input image.
    kernel_size: integer or 2-tuple
        Defines the shape of contextual regions used in the algorithm.
        If an integer is given, the shape will be a square of
        sidelength given by this value.
    ntiles_x : int, optional (deprecated in favor of ``kernel_size``)
        Number of tile regions in the X direction (horizontal).
    ntiles_y : int, optional (deprecated in favor of ``kernel_size``)
        Number of tile regions in the Y direction (vertical).
    clip_limit : float: optional
        Clipping limit, normalized between 0 and 1 (higher values give more
        contrast).
    nbins : int, optional
        Number of gray bins for histogram ("dynamic range").
 
    Returns
    -------
    out : ndarray
        Equalized image.
 
    See Also
    --------
    equalize_hist, rescale_intensity
 
    Notes
    -----
    * For color images, the following steps are performed:
       - The image is converted to HSV color space
       - The CLAHE algorithm is run on the V (Value) channel
       - The image is converted back to RGB space and returned
    * For RGBA images, the original alpha channel is removed.
 
    References
    ----------
    .. [1] http://tog.acm.org/resources/GraphicsGems/
    .. [2] https://en.wikipedia.org/wiki/CLAHE#CLAHE
    """
    image = img_as_uint(image)
    image = rescale_intensity(image, out_range=(0, NR_OF_GREY - 1))
 
    if ntiles_x is not None or ntiles_y is not None:
        warn('`ntiles_*` have been deprecated in favor of '
             '`kernel_size`.  The `ntiles_*` keyword arguments '
             'will be removed in v0.14', skimage_deprecation)
 
    if kernel_size is None:
        ntiles_x = ntiles_x or 8
        ntiles_y = ntiles_y or 8
        kernel_size = (np.round(image.shape[0] / ntiles_y),
                       np.round(image.shape[1] / ntiles_x))
 
    if isinstance(kernel_size, numbers.Number):
        kernel_size = (kernel_size, kernel_size)
 
    kernel_size = [int(k) for k in kernel_size]
 
    image = _clahe(image, kernel_size, clip_limit * nbins, nbins)
    image = img_as_float(image)
    return rescale_intensity(image)

def _clahe(image, kernel_size, clip_limit, nbins=128):
    """Contrast Limited Adaptive Histogram Equalization.
 
    Parameters
    ----------
    image : array-like
        Input image.
    kernel_size: 2-tuple
        Defines the shape of contextual regions used in the algorithm.
    clip_limit : float, optional
        Normalized clipping limit (higher values give more contrast).
    nbins : int, optional
        Number of gray bins for histogram ("dynamic range").
 
    Returns
    -------
    out : ndarray
        Equalized image.
 
    The number of "effective" greylevels in the output image is set by `nbins`;
    selecting a small value (eg. 128) speeds up processing and still produce
    an output image of good quality. The output image will have the same
    minimum and maximum value as the input image. A clip limit smaller than 1
    results in standard (non-contrast limited) AHE.
    """
 
    if clip_limit == 1.0:
        return image  # is OK, immediately returns original image.
 
    nr = int(np.ceil(image.shape[0] / kernel_size[0]))
    nc = int(np.ceil(image.shape[1] / kernel_size[1]))
 
    row_step = int(np.floor(image.shape[0] / nr))
    col_step = int(np.floor(image.shape[1] / nc))
 
    bin_size = 1 + NR_OF_GREY // nbins
    lut = np.arange(NR_OF_GREY)
    lut //= bin_size
 
    map_array = np.zeros((nr, nc, nbins), dtype=int)
 
    # Calculate greylevel mappings for each contextual region
    for r in range(nr):
        for c in range(nc):
            sub_img = image[r * row_step: (r + 1) * row_step,
                            c * col_step: (c + 1) * col_step]
 
            if clip_limit > 0.0:  # Calculate actual cliplimit
                clim = int(clip_limit * sub_img.size / nbins)
                if clim < 1:
                    clim = 1
            else:
                clim = NR_OF_GREY  # Large value, do not clip (AHE)
 
            hist = lut[sub_img.ravel()]
            hist = np.bincount(hist)
            hist = np.append(hist, np.zeros(nbins - hist.size, dtype=int))
            hist = clip_histogram(hist, clim)
            hist = map_histogram(hist, 0, NR_OF_GREY - 1, sub_img.size)
            map_array[r, c] = hist
 
    # Interpolate greylevel mappings to get CLAHE image
    rstart = 0
    for r in range(nr + 1):
        cstart = 0
        if r == 0:  # special case: top row
            r_offset = row_step / 2.0
            rU = 0
            rB = 0
        elif r == nr:  # special case: bottom row
            r_offset = row_step / 2.0
            rU = nr - 1
            rB = rU
        else:  # default values
            r_offset = row_step
            rU = r - 1
            rB = rB + 1
 
        for c in range(nc + 1):
            if c == 0:  # special case: left column
                c_offset = col_step / 2.0
                cL = 0
                cR = 0
            elif c == nc:  # special case: right column
                c_offset = col_step / 2.0
                cL = nc - 1
                cR = cL
            else:  # default values
                c_offset = col_step
                cL = c - 1
                cR = cL + 1
 
            mapLU = map_array[rU, cL]
            mapRU = map_array[rU, cR]
            mapLB = map_array[rB, cL]
            mapRB = map_array[rB, cR]
 
            cslice = np.arange(cstart, cstart + c_offset)
            rslice = np.arange(rstart, rstart + r_offset)
 
            interpolate(image, cslice, rslice,
                        mapLU, mapRU, mapLB, mapRB, lut)
 
            cstart += c_offset  # set pointer on next matrix */
 
        rstart += r_offset
 
    return image